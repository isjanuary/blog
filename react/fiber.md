## 说说 fiber






本文翻译自 React 团队关于 React 16 的官方博文
>原文标题： React 16: A look inside an API-compatible rewrite of our frontend UI library

### React 16： 了解我们对 React API 兼容的重写

React 让我们能够简单地在网页和移动端构建函数式的，基于组件的 UI；在 Facebook，仅仅在我们主页面仓库，我们已经有了 30,000 个以上的
React 组件。React 的易用性和功能性使得其被 Facebook 之外的众多开发者采用。随着今天 React 16 的发布，我们已经完全重写了 React 内核，
而不用去修改必要的公共 API。从工程的角度讲，这有点像从一辆行驶的车里把引擎置换出来一样：因为数百家其他企业(包括 Facebook)每天在产品
中使用 React，我们想要在不让人们用 React 重写其组件的前提下将 React 内核置换出来。

新的实现从底层开始就被设计成支持异步渲染，这能允许 React 在处理庞大组件树的时候不用阻塞主执行线程。我们也趁此机会完成了频繁要求的特性，
它们之前很难做，比如使用错误边界捕获异常，从 render 方法返回多个组件。在 [React Conf keynote](https://www.youtube.com/playlist?list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0) 里我们已经提到了有关这次重写背后动机的更多细节，但我们还是想要带幕后的开发者看一看，在一个大型产品应用的背景下，我们是如何真正构造并测试这些新的功能实现。

#### 开发重写

对于大多数 Facebook 的特性开发，我们不会在我们的代码仓库中使用长期运行的分支(branch)，因为我们发现当多个 branch 必须要被合并到一起的时候，我们要花很多功夫来处理 merge conflicts。替代的方法是，我们使用一种基于 feature flag 的方法，这种方法是说代码被提交到同一个代码仓库，但 feature 可以通过运行时的检查来打开或禁止。一旦代码准备好了，发布 feature 只需要简单地包含修改这些 bool 值就行了。

对于重写，也就是在开发中我们称其为 React Fiber 的东西，我们采用同样的方法：在我们 Github 仓库里，我们把所有的新代码和老代码写在一起，
然后用一个 bool 值 `useFiber` 来控制新老版本的切换。这样的流程允许我们开始构建新的实现，而不会影响到任何现在的用户，而且在必要时往老代
码里提交 bugfix 的时候也可以开发新的实现。我们做了一个单独的入口，它会检查 feature flag 并且会视情况导入新的还老的 renderer 文件。

我们想要用完全匹配的特性来重构 React，所以我们第一个长期目标是，运行新代码的时候让我们目前的 Jest 测试套件通过。新的 renderer 是以骨架实现开始的，它仅支持很有限的 React API 的子集，然后随着时间的推移我们添加特性以使更多测试通过，以一种测试驱动开发的形式进行。
我们的绝大多数测试已经使用了 React 的公共 API，所以当新的实现做好了以后运行这些测试挺简单的。我们也发现有一些测试依赖于旧代码的实现
细节并且重写了这些测试。

通常来说，新实现的全新一天的工作从打开 feature flag 和运行 React 单元测试开始，我们会挑一个失败的测试，然后修改 renderer 代码以使
测试通过。在许多情形下，很多测试会因为同一个问题失败，因此一个测试的 fix 通常也会 fix 其他的。

